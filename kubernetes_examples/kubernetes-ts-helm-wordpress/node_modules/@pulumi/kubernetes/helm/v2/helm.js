"use strict";
// Copyright 2016-2020, Pulumi Corporation.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
Object.defineProperty(exports, "__esModule", { value: true });
// *** WARNING: this file was generated by the pulumigen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***
const pulumi = require("@pulumi/pulumi");
const child_process_1 = require("child_process");
const fs = require("fs");
const nodepath = require("path");
const shell = require("shell-quote");
const tmp = require("tmp");
const path = require("../../path");
const utilities_1 = require("../../utilities");
const yaml = require("../../yaml/index");
/**
 * Chart is a component representing a collection of resources described by an arbitrary Helm
 * Chart. The Chart can be fetched from any source that is accessible to the `helm` command
 * line. Values in the `values.yml` file can be overridden using `ChartOpts.values` (equivalent
 * to `--set` or having multiple `values.yml` files). Objects can be transformed arbitrarily by
 * supplying callbacks to `ChartOpts.transformations`.
 *
 * `Chart` does not use Tiller. The Chart specified is copied and expanded locally; the semantics
 * are equivalent to running `helm template` and then using Pulumi to manage the resulting YAML
 * manifests. Any values that would be retrieved in-cluster are assigned fake values, and
 * none of Tiller's server-side validity testing is executed.
 *
 * ## Example Usage
 * ### Local Chart Directory
 *
 * ```typescript
 * import * as k8s from "@pulumi/kubernetes";
 *
 * const nginxIngress = new k8s.helm.v2.Chart("nginx-ingress", {
 *   path: "./nginx-ingress",
 * });
 * ```
 * ### Remote Chart
 *
 * ```typescript
 * import * as k8s from "@pulumi/kubernetes";
 *
 * const nginxIngress = new k8s.helm.v2.Chart("nginx-ingress", {
 *   chart: "nginx-ingress",
 *   version: "1.24.4",
 *   fetchOpts:{
 *     repo: "https://charts.helm.sh/stable",
 *   },
 * });
 * ```
 * ### Set Chart values
 *
 * ```typescript
 * import * as k8s from "@pulumi/kubernetes";
 *
 * const nginxIngress = new k8s.helm.v2.Chart("nginx-ingress", {
 *   chart: "nginx-ingress",
 *   version: "1.24.4",
 *   fetchOpts:{
 *     repo: "https://charts.helm.sh/stable",
 *   },
 *   values: {
 *     controller: {
 *       metrics: {
 *         enabled: true,
 *       }
 *     }
 *   },
 * });
 * ```
 * ### Deploy Chart into Namespace
 *
 * ```typescript
 * import * as k8s from "@pulumi/kubernetes";
 *
 * const nginxIngress = new k8s.helm.v2.Chart("nginx-ingress", {
 *   chart: "nginx-ingress",
 *   version: "1.24.4",
 *   namespace: "test-namespace",
 *   fetchOpts:{
 *     repo: "https://charts.helm.sh/stable",
 *   },
 * });
 * ```
 * ### Chart with Transformations
 *
 * ```typescript
 * import * as k8s from "@pulumi/kubernetes";
 *
 * const nginxIngress = new k8s.helm.v2.Chart("nginx-ingress", {
 *   chart: "nginx-ingress",
 *   version: "1.24.4",
 *   fetchOpts:{
 *     repo: "https://charts.helm.sh/stable",
 *   },
 *   transformations: [
 *     // Make every service private to the cluster, i.e., turn all services into ClusterIP instead of LoadBalancer.
 *     (obj: any, opts: pulumi.CustomResourceOptions) => {
 *       if (obj.kind === "Service" && obj.apiVersion === "v1") {
 *         if (obj.spec && obj.spec.type && obj.spec.type === "LoadBalancer") {
 *           obj.spec.type = "ClusterIP";
 *         }
 *       }
 *     },
 *
 *     // Set a resource alias for a previous name.
 *     (obj: any, opts: pulumi.CustomResourceOptions) => {
 *     if (obj.kind === "Deployment") {
 *       opts.aliases = [{ name: "oldName" }]
 *     },
 *
 *     // Omit a resource from the Chart by transforming the specified resource definition to an empty List.
 *     (obj: any, opts: pulumi.CustomResourceOptions) => {
 *     if (obj.kind === "Pod" && obj.metadata.name === "test") {
 *       obj.apiVersion = "v1"
 *       obj.kind = "List"
 *     },
 *   ],
 * });
 * ```
 */
class Chart extends yaml.CollectionComponentResource {
    /**
     * Create an instance of the specified Helm chart.
     * @param releaseName Name of the Chart (e.g., nginx-ingress).
     * @param config Configuration options for the Chart.
     * @param opts A bag of options that control this resource's behavior.
     */
    constructor(releaseName, config, opts) {
        if (config.resourcePrefix !== undefined) {
            releaseName = `${config.resourcePrefix}-${releaseName}`;
        }
        super("kubernetes:helm.sh/v2:Chart", releaseName, config, opts);
        const allConfig = pulumi.output(config);
        const configDeps = Array.from(allConfig.resources());
        allConfig.isKnown.then((isKnown) => {
            if (!isKnown) {
                // Note that this can only happen during a preview.
                pulumi.log.info("[Can't preview] all chart values must be known ahead of time to generate an accurate preview.", this);
            }
        });
        this.resources = allConfig.apply(cfg => {
            // Create temporary directories and files to hold chart data and override values.
            const overrides = tmp.fileSync({ postfix: ".yaml" });
            const chartDir = tmp.dirSync({ unsafeCleanup: true });
            try {
                let chart;
                let defaultValues;
                let cmd;
                if (isChartOpts(cfg)) {
                    // Fetch chart.
                    if (cfg.repo && cfg.repo.includes("http")) {
                        pulumi.log.error("`repo` specifies the name of the Helm chart repo. Use `fetchOpts.repo` to specify a URL.", this);
                    }
                    const chartToFetch = cfg.repo ? `${cfg.repo}/${cfg.chart}` : cfg.chart;
                    const fetchOpts = Object.assign({}, cfg.fetchOpts, {
                        destination: chartDir.name,
                        version: cfg.version
                    });
                    fetch(chartToFetch, fetchOpts);
                    const fetchedChartName = fs.readdirSync(chartDir.name).sort()[0];
                    chart = path.quotePath(nodepath.join(chartDir.name, fetchedChartName));
                    defaultValues = path.quotePath(nodepath.join(chartDir.name, fetchedChartName, "values.yaml"));
                }
                else {
                    chart = cfg.path;
                    defaultValues = path.quotePath(nodepath.join(chart, "values.yaml"));
                }
                // Write overrides file.
                const data = JSON.stringify(cfg.values || {}, undefined, "  ");
                fs.writeFileSync(overrides.name, data);
                // Does not require Tiller. From the `helm template` documentation:
                //
                // >  Render chart templates locally and display the output.
                // >
                // > This does not require Tiller. However, any values that would normally be
                // > looked up or retrieved in-cluster will be faked locally. Additionally, none
                // > of the server-side testing of chart validity (e.g. whether an API is supported)
                // > is done.
                const release = shell.quote([releaseName]);
                const values = path.quotePath(overrides.name);
                const apiVersionsArgs = cfg.apiVersions
                    ? cfg.apiVersions
                        .map(v => `--api-versions=${v}`)
                        .join(" ")
                    : "";
                const namespaceArg = cfg.namespace
                    ? `--namespace ${shell.quote([cfg.namespace])}`
                    : "";
                // Check the helm version - v2 or v3
                let helmVerCmd = `helm version --short || true`;
                var helmVer;
                try {
                    helmVer = child_process_1.execSync(helmVerCmd, {
                        stdio: ['pipe', 'pipe', 'ignore'],
                    }).toString();
                }
                catch (e) {
                    helmVer = e.stdout.toString();
                }
                cmd = `helm template ${chart} --name-template ${release} --values ${defaultValues} --values ${values} ${apiVersionsArgs} ${namespaceArg}`;
                // Helm v2 returns version like this:
                // Client: v2.16.7+g5f2584f
                // Helm v3 returns a version like this:
                // v3.1.2+gd878d4d
                // --include-crds is available in helm v3.1+ so check for a regex matching that version
                if (RegExp('^v3\.[1-9]').test(helmVer)) {
                    cmd += ` --include-crds`;
                }
                const yamlStream = child_process_1.execSync(cmd, {
                    env: Object.assign({}, process.env),
                    maxBuffer: 512 * 1024 * 1024 // 512 MB
                }).toString();
                return this.parseTemplate(yamlStream, cfg.transformations, cfg.resourcePrefix, configDeps, cfg.namespace);
            }
            catch (e) {
                // Shed stack trace, only emit the error.
                throw new pulumi.RunError(e.toString());
            }
            finally {
                // Clean up temporary files and directories.
                chartDir.removeCallback();
                overrides.removeCallback();
            }
        });
        this.ready = this.resources.apply(m => Object.values(m));
    }
    parseTemplate(text, transformations, resourcePrefix, dependsOn, defaultNamespace) {
        // Rather than using the default provider for the following invoke call, use the version specified
        // in package.json.
        let invokeOpts = { async: true, version: utilities_1.getVersion() };
        const promise = pulumi.runtime.invoke("kubernetes:yaml:decode", { text, defaultNamespace }, invokeOpts);
        return pulumi.output(promise).apply(p => yaml.parse({
            resourcePrefix: resourcePrefix,
            objs: p.result,
            transformations: transformations || [],
        }, { parent: this, dependsOn: dependsOn }));
    }
}
exports.Chart = Chart;
function isChartOpts(o) {
    return "chart" in o;
}
function isLocalChartOpts(o) {
    return "path" in o;
}
/**
 * Retrieve a package from a package repository, and download it locally.
 *
 * This is useful for fetching packages to inspect, modify, or repackage. It can also be used to
 * perform cryptographic verification of a chart without installing the chart.
 *
 * There are options for unpacking the chart after download. This will create a directory for the
 * chart and uncompress into that directory.
 *
 * If the `verify` option is specified, the requested chart MUST have a provenance file, and MUST
 * pass the verification process. Failure in any part of this will result in an error, and the chart
 * will not be saved locally.
 *
 * @ignore
 */
function fetch(chart, opts) {
    const flags = [];
    const env = Object.assign({}, process.env);
    if (opts !== undefined) {
        // Untar by default.
        if (opts.untar !== false) {
            flags.push(`--untar`);
        }
        // Helm v3 removed the `--home` flag, so we must use an env var instead.
        if (opts.home) {
            env['HELM_HOME'] = path.quotePath(opts.home);
        }
        // For arguments that are not paths to files, it is sufficient to use shell.quote to quote the arguments.
        // However, for arguments that are actual paths to files we use path.quotePath (note that path here is
        // not the node path builtin module). This ensures proper escaping of paths on Windows.
        if (opts.version !== undefined) {
            flags.push(`--version ${shell.quote([opts.version])}`);
        }
        if (opts.caFile !== undefined) {
            flags.push(`--ca-file ${path.quotePath(opts.caFile)}`);
        }
        if (opts.certFile !== undefined) {
            flags.push(`--cert-file ${path.quotePath(opts.certFile)}`);
        }
        if (opts.keyFile !== undefined) {
            flags.push(`--key-file ${path.quotePath(opts.keyFile)}`);
        }
        if (opts.destination !== undefined) {
            flags.push(`--destination ${path.quotePath(opts.destination)}`);
        }
        if (opts.keyring !== undefined) {
            flags.push(`--keyring ${path.quotePath(opts.keyring)}`);
        }
        if (opts.password !== undefined) {
            flags.push(`--password ${shell.quote([opts.password])}`);
        }
        if (opts.repo !== undefined) {
            flags.push(`--repo ${path.quotePath(opts.repo)}`);
        }
        if (opts.untardir !== undefined) {
            flags.push(`--untardir ${path.quotePath(opts.untardir)}`);
        }
        if (opts.username !== undefined) {
            flags.push(`--username ${shell.quote([opts.username])}`);
        }
        if (opts.devel === true) {
            flags.push(`--devel`);
        }
        if (opts.prov === true) {
            flags.push(`--prov`);
        }
        if (opts.verify === true) {
            flags.push(`--verify`);
        }
    }
    child_process_1.execSync(`helm fetch ${shell.quote([chart])} ${flags.join(" ")}`, { env });
}
exports.fetch = fetch;
//# sourceMappingURL=helm.js.map