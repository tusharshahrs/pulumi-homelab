"use strict";
// Copyright 2016-2020, Pulumi Corporation.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
Object.defineProperty(exports, "__esModule", { value: true });
// *** WARNING: this file was generated by the pulumigen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***
const pulumi = require("@pulumi/pulumi");
const utilities_1 = require("../../utilities");
const yaml = require("../../yaml/index");
/**
 * Chart is a component representing a collection of resources described by an arbitrary Helm
 * Chart. The Chart can be fetched from any source that is accessible to the `helm` command
 * line. Values in the `values.yml` file can be overridden using `ChartOpts.values` (equivalent
 * to `--set` or having multiple `values.yml` files). Objects can be transformed arbitrarily by
 * supplying callbacks to `ChartOpts.transformations`.
 *
 * `Chart` does not use Tiller. The Chart specified is copied and expanded locally; the semantics
 * are equivalent to running `helm template` and then using Pulumi to manage the resulting YAML
 * manifests. Any values that would be retrieved in-cluster are assigned fake values, and
 * none of Tiller's server-side validity testing is executed.
 *
 * ## Example Usage
 * ### Local Chart Directory
 *
 * ```typescript
 * import * as k8s from "@pulumi/kubernetes";
 *
 * const nginxIngress = new k8s.helm.v3.Chart("nginx-ingress", {
 *   path: "./nginx-ingress",
 * });
 * ```
 * ### Remote Chart
 *
 * ```typescript
 * import * as k8s from "@pulumi/kubernetes";
 *
 * const nginxIngress = new k8s.helm.v3.Chart("nginx-ingress", {
 *   chart: "nginx-ingress",
 *   version: "1.24.4",
 *   fetchOpts:{
 *     repo: "https://charts.helm.sh/stable",
 *   },
 * });
 * ```
 * ### Set Chart values
 *
 * ```typescript
 * import * as k8s from "@pulumi/kubernetes";
 *
 * const nginxIngress = new k8s.helm.v3.Chart("nginx-ingress", {
 *   chart: "nginx-ingress",
 *   version: "1.24.4",
 *   fetchOpts:{
 *     repo: "https://charts.helm.sh/stable",
 *   },
 *   values: {
 *     controller: {
 *       metrics: {
 *         enabled: true,
 *       }
 *     }
 *   },
 * });
 * ```
 * ### Deploy Chart into Namespace
 *
 * ```typescript
 * import * as k8s from "@pulumi/kubernetes";
 *
 * const nginxIngress = new k8s.helm.v3.Chart("nginx-ingress", {
 *   chart: "nginx-ingress",
 *   version: "1.24.4",
 *   namespace: "test-namespace",
 *   fetchOpts:{
 *     repo: "https://charts.helm.sh/stable",
 *   },
 * });
 * ```
 * ### Chart with Transformations
 *
 * ```typescript
 * import * as k8s from "@pulumi/kubernetes";
 *
 * const nginxIngress = new k8s.helm.v3.Chart("nginx-ingress", {
 *   chart: "nginx-ingress",
 *   version: "1.24.4",
 *   fetchOpts:{
 *     repo: "https://charts.helm.sh/stable",
 *   },
 *   transformations: [
 *     // Make every service private to the cluster, i.e., turn all services into ClusterIP instead of LoadBalancer.
 *     (obj: any, opts: pulumi.CustomResourceOptions) => {
 *       if (obj.kind === "Service" && obj.apiVersion === "v1") {
 *         if (obj.spec && obj.spec.type && obj.spec.type === "LoadBalancer") {
 *           obj.spec.type = "ClusterIP";
 *         }
 *       }
 *     },
 *
 *     // Set a resource alias for a previous name.
 *     (obj: any, opts: pulumi.CustomResourceOptions) => {
 *     if (obj.kind === "Deployment") {
 *       opts.aliases = [{ name: "oldName" }]
 *     },
 *
 *     // Omit a resource from the Chart by transforming the specified resource definition to an empty List.
 *     (obj: any, opts: pulumi.CustomResourceOptions) => {
 *     if (obj.kind === "Pod" && obj.metadata.name === "test") {
 *       obj.apiVersion = "v1"
 *       obj.kind = "List"
 *     },
 *   ],
 * });
 * ```
 */
class Chart extends yaml.CollectionComponentResource {
    /**
     * Create an instance of the specified Helm chart.
     * @param releaseName Name of the Chart (e.g., nginx-ingress).
     * @param config Configuration options for the Chart.
     * @param opts A bag of options that control this resource's behavior.
     */
    constructor(releaseName, config, opts) {
        if (config.resourcePrefix !== undefined) {
            releaseName = `${config.resourcePrefix}-${releaseName}`;
        }
        const aliasOpts = Object.assign(Object.assign({}, opts), { aliases: [{ type: "kubernetes:helm.sh/v2:Chart" }] });
        super("kubernetes:helm.sh/v3:Chart", releaseName, config, aliasOpts);
        const allConfig = pulumi.output(config);
        allConfig.isKnown.then((isKnown) => {
            if (!isKnown) {
                // Note that this can only happen during a preview.
                pulumi.log.info("[Can't preview] all chart values must be known ahead of time to generate an " +
                    "accurate preview.", this);
            }
        });
        this.resources = allConfig.apply(cfg => {
            return this.parseChart(cfg, releaseName, opts);
        });
        this.ready = this.resources.apply(m => Object.values(m));
    }
    parseChart(config, releaseName, opts) {
        const blob = Object.assign(Object.assign({}, config), { releaseName,
            toJSON() {
                let obj = {};
                for (const [key, value] of Object.entries(this)) {
                    if (value) {
                        switch (key) {
                            case "apiVersions": {
                                obj["api_versions"] = value;
                                break;
                            }
                            case "caFile": {
                                obj["ca_file"] = value;
                                break;
                            }
                            case "certFile": {
                                obj["cert_file"] = value;
                                break;
                            }
                            case "fetchOpts": {
                                obj["fetch_opts"] = value;
                                break;
                            }
                            case "releaseName": {
                                obj["release_name"] = value;
                                break;
                            }
                            case "resourcePrefix": {
                                obj["resource_prefix"] = value;
                                break;
                            }
                            case "untardir": {
                                obj["untar_dir"] = value;
                                break;
                            }
                            default: {
                                obj[key] = value;
                            }
                        }
                    }
                }
                return obj;
            } });
        const jsonOpts = JSON.stringify(blob);
        // Rather than using the default provider for the following invoke call, use the version specified
        // in package.json.
        let invokeOpts = { async: true, version: utilities_1.getVersion() };
        const promise = pulumi.runtime.invoke("kubernetes:helm:template", { jsonOpts }, invokeOpts);
        return pulumi.output(promise).apply(p => yaml.parse({
            resourcePrefix: config.resourcePrefix,
            objs: p.result,
            transformations: config.transformations || [],
        }, Object.assign(Object.assign({}, opts), { parent: this })));
    }
}
exports.Chart = Chart;
function isChartOpts(o) {
    return "chart" in o;
}
function isLocalChartOpts(o) {
    return "path" in o;
}
//# sourceMappingURL=helm.js.map